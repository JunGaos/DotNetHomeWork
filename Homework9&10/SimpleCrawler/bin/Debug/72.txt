<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin-when-crossorigin" />
    <meta name="description" content="ES是一个分布式搜索引擎，其除了用户提供必要的通信服务外，集群间也必须保持紧密的通信联系，才能在必要的时候给出正确的结果。其则必然涉及到各种繁多且要求高的通信场景，那么如何实现高性能的通信，则是其必须" />
    <meta property="og:description" content="ES是一个分布式搜索引擎，其除了用户提供必要的通信服务外，集群间也必须保持紧密的通信联系，才能在必要的时候给出正确的结果。其则必然涉及到各种繁多且要求高的通信场景，那么如何实现高性能的通信，则是其必须" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>ES系列(三)：网络通信模块解析 - 等你归去来 - 博客园</title>
    <link id="favicon" rel="shortcut icon" href="//common.cnblogs.com/favicon.svg" type="image/svg+xml" />
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=zS6-e1bxywlu3kpHvpr1J6MySwya3ztFtEnS7RYQ0Fk" />
    <link id="MainCss" rel="stylesheet" href="/skins/codinglife/bundle-codinglife.min.css?v=2uJkpdACLVfstRQ7zeCFK19brTwKuDEaNBLgKz9nm3A" />
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/yougewe/custom.css?v=P8TSMG0CFucThY7zv658b3Zxvwk=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/codinglife/bundle-codinglife-mobile.min.css?v=DwDRKMd1bmjnJZ4iQqrTCO9QLlYb6OZaUAzHoHIIihg" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/yougewe/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/yougewe/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/yougewe/wlwmanifest.xml" />
    <script>
        var currentBlogId = 251865;
        var currentBlogApp = 'yougewe';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var isBlogOwner = false;
        var skinName = 'CodingLife';
        var visitorUserId = '';
    </script>
        <script>
            var currentPostDateAdded = '2021-05-02 04:09';
        </script>
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=yJQaJ16S00coMfzvh-NgF2zm2J87f5VfNamFdsnKHrc"></script>
    
    
    
</head>
<body class="no-navbar">
    <a name="top"></a>
        <div id="bannerbar" class="bannerbar-mobile formobile">
            <a href="https://www.aliyun.com/minisite/goods?userCode=swh7dvlt" target="_blank" onclick="ga('send', 'event', 'Link', 'click', 'aliyun-cps-blog-bannerbar-mobile')">
                <img src="https://img2020.cnblogs.com/blog/35695/202104/35695-20210428213541700-642740375.jpg" alt="" />
            </a>
        </div>
    <div id="top_nav" class="navbar forpc navbar-custom">
        <nav id="nav_main" class="navbar-main">
            <ul id="nav_left" class="navbar-list navbar-left">
                <li class="navbar-branding"><a href="https://www.cnblogs.com/" title="开发者的网上家园"><img src="/images/logo.svg?v=R9M0WmLAIPVydmdzE2keuvnjl-bPR7_35oHqtiBzGsM" alt="博客园Logo" /></a></li>
                <li><a href="/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-sitehome')">首页</a></li>
                <li><a href="https://news.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-news')">新闻</a></li>
                <li><a href="https://q.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-q')">博问</a></li>
                <li><a id="nav_brandzone" href="https://brands.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-brands')">专区</a></li>
                <li><a href="https://ing.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-ing')">闪存</a></li>
                <li><a href="https://edu.cnblogs.com/" onclick="ga('send', 'event', 'Link', 'click', 'skin-navbar-edu')">班级</a></li>
            </ul>
            <ul id="nav_right" class="navbar-list navbar-right">
                <li>
                    <form id="zzk_search" class="navbar-search" action="https://zzk.cnblogs.com/s" method="get">
                        <input name="w" id="zzk_search_input" placeholder="代码改变世界" type="text" tabindex="3" />
                        <button type="submit" id="zzk_search_button">
                            <img src="/images/aggsite/search.svg" alt="搜索" />
                        </button>
                    </form>
                </li>
                <li id="navbar_login_status" class="navbar-list">
                    <a class="navbar-user-info navbar-blog" href="https://i.cnblogs.com/EditPosts.aspx?opt=1" alt="写随笔" title="写随笔">
                        <img id="new_post_icon" class="navbar-icon" src="/images/aggsite/newpost.svg" alt="写随笔" />
                    </a>
                    <a id="navblog-myblog-icon" class="navbar-user-info navbar-blog" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx" alt="我的博客" title="我的博客">
                        <img id="myblog_icon" class="navbar-icon" src="/images/aggsite/myblog.svg" alt="我的博客" />
                    </a>
                    <a class="navbar-user-info navbar-message navbar-icon-wrapper" href="https://msg.cnblogs.com/" alt="短消息" title="短消息">
                        <img id="msg_icon" class="navbar-icon" src="/images/aggsite/message.svg?v=J0WS2P2iPgaIVgXxcAhliw4AFZIpaTWxtdoNAv9eiCA" alt="短消息" />
                        <span id="msg_count" style="display: none"></span>
                    </a>
                    <div id="user_info" class="navbar-user-info dropdown">
                        <a class="dropdown-button" href="https://home.cnblogs.com/">
                            <img id="user_icon" class="navbar-avatar" src="/images/aggsite/avatar-default.svg" alt="用户头像" />
                        </a>
                        <div class="dropdown-menu">
                            <a id="navblog-myblog-text" href="https://passport.cnblogs.com/GetBlogApplyStatus.aspx">我的博客</a>
                            <a href="https://home.cnblogs.com/">我的园子</a>
                            <a href="https://account.cnblogs.com/settings/account">账号设置</a>
                            <a href="javascript:void(0)" id="navbar_lite_mode_toggle" title="简洁模式会使用简洁款皮肤显示所有博客">
    简洁模式 <img id="navbar_lite_mode_on" src="/images/lite-mode-check.svg" class="hide" /><span id="navbar_lite_mode_spinner" class="hide">...</span>
</a>
                            <a href="javascript:void(0)" onclick="account.logout();">退出登录</a>
                        </div>
                    </div>
                    <a class="navbar-anonymous" href="https://account.cnblogs.com/signup/">注册</a>
                    <a class="navbar-anonymous" href="javascript:void(0);" onclick="account.login()">登录</a>
                </li>
            </ul>
        </nav>
    </div>

    
    <!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/yougewe/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/yougewe/">等你归去来</a>
</h1>
<h2>我约我期，要么求变，否则忍受，等你归去来！</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/yougewe/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E7%AD%89%E4%BD%A0%E5%BD%92%E5%8E%BB%E6%9D%A5">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="javascript:void(0)" data-rss="https://www.cnblogs.com/yougewe/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			<div id="blog_stats_place_holder"><script>loadBlogStats();</script></div>
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->
<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2 vertical-middle" href="https://www.cnblogs.com/yougewe/p/14725872.html">
    <span>ES系列(三)：网络通信模块解析</span>
    



</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html">
<p>　　ES是一个分布式搜索引擎，其除了用户提供必要的通信服务外，集群间也必须保持紧密的通信联系，才能在必要的时候给出正确的结果。其则必然涉及到各种繁多且要求高的通信场景，那么如何实现高性能的通信，则是其必须要考虑的问题。</p>
<p>　　今天，我们就以es的transportService的实现为窥点，观察es的高性能的通信模块实现吧。</p>
<p>&nbsp;</p>
<h3>1. 前言概要</h3>
<p>　　谈到高性能的网络通信，相信很多人都明白大概是什么道理，或者看过我之前的一些文章，也必然清楚其核心原理。总结来说，其实就是利用io多路复用技术，充分利用带宽，从而达到高性能的目标。</p>
<p>　　而具体到java语言上来，能聊的点也许就更少了。比如nio, netty, akka...&nbsp;</p>
<p>　　所以，其实本文所讨论的目标，看起来没有那么神秘，也没必要神秘。我们仅站在研究ES实现细节的方向，去深入理解一些实际的问题，目的仅是为了解惑。</p>
<p>　　</p>
<h3>2. transportService的初始化</h3>
<p>　　es中几乎所有的模块，都是在服务启动的时候进行初始化的，这是自然。一来是启动时缓慢一点是可以的，二来是启动的时候有非常多的上下文信息可用非常方便各种初始化，三来是能够提前发现问题而不是运行了很久之后才发现不可解决的问题。</p>
<p>　　而transportService是在创建Node时进行初始化的。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.node.Node#start</span>
    <span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * Constructs a node
     *
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> initialEnvironment         the initial environment for this node, which will be added to by plugins
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> classpathPlugins           the plugins to be loaded from the classpath
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> forbidPrivateIndexSettings whether or not private index settings are forbidden when creating an index; this is used in the
     *                                   test framework for tests that rely on being able to set private settings
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">protected</span> Node(<span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> Environment initialEnvironment,
                   Collection</span>&lt;Class&lt;? <span style="color: rgba(0, 0, 255, 1)">extends</span> Plugin&gt;&gt; classpathPlugins, <span style="color: rgba(0, 0, 255, 1)">boolean</span><span style="color: rgba(0, 0, 0, 1)"> forbidPrivateIndexSettings) {
        ...
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            ...
            </span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> TemplateUpgradeService(client, clusterService, threadPool, indexTemplateMetadataUpgraders);
            </span><span style="color: rgba(0, 0, 255, 1)">final</span> Transport transport =<span style="color: rgba(0, 0, 0, 1)"> networkModule.getTransportSupplier().get();
            Set</span>&lt;String&gt; taskHeaders =<span style="color: rgba(0, 0, 0, 1)"> Stream.concat(
                pluginsService.filterPlugins(ActionPlugin.</span><span style="color: rgba(0, 0, 255, 1)">class</span>).stream().flatMap(p -&gt;<span style="color: rgba(0, 0, 0, 1)"> p.getTaskHeaders().stream()),
                Stream.of(Task.X_OPAQUE_ID)
            ).collect(Collectors.toSet());
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 创建 transportService</span>
            <span style="color: rgba(0, 0, 255, 1)">final</span> TransportService transportService =<span style="color: rgba(0, 0, 0, 1)"> newTransportService(settings, transport, threadPool,
                networkModule.getTransportInterceptor(), localNodeFactory, settingsModule.getClusterSettings(), taskHeaders);
            </span><span style="color: rgba(0, 0, 255, 1)">final</span> GatewayMetaState gatewayMetaState = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> GatewayMetaState();
            ...
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (IOException ex) {
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> ElasticsearchException("failed to bind service"<span style="color: rgba(0, 0, 0, 1)">, ex);
        } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">success) {
                IOUtils.closeWhileHandlingException(resourcesToClose);
            }
        }
    }</span></pre>
</div>
<p>　　即要初始化 transportService ， 重点就要看 newTransportService（） 如何处理了。在当然了，要进行这个方法的调用，它其实比较多的前提，即各种入参的初始化。重要一点的就是：线程池的创建，transport 的初始化。线程池咱们略去不说，主要是它会在非常多的地方用到，单独在这里讲也不合适。那么就主要看看 transport 是如何初始化的即可。</p>
<p>&nbsp;</p>
<h4>2.1. NetworkModule 的实例化</h4>
<p>　　从上面的实现中，我们看到要获取 transport 实例，还需要先拿到 networkModule ，这又是如何初始化的呢？</p>
<div class="cnblogs_code">
<pre>            <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 在 Node() 的构造方法中，直接new出来的 。</span>
            <span style="color: rgba(0, 0, 255, 1)">final</span> NetworkModule networkModule = <span style="color: rgba(0, 0, 255, 1)">new</span> NetworkModule(settings, <span style="color: rgba(0, 0, 255, 1)">false</span>, pluginsService.filterPlugins(NetworkPlugin.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">),
                threadPool, bigArrays, pageCacheRecycler, circuitBreakerService, namedWriteableRegistry, xContentRegistry,
                networkService, restController, clusterService.getClusterSettings());
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.common.network.NetworkModule#NetworkModule</span>
    <span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * Creates a network module that custom networking classes can be plugged into.
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> settings The settings for the node
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> transportClient True if only transport classes should be allowed to be registered, false otherwise.
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> NetworkModule(Settings settings, <span style="color: rgba(0, 0, 255, 1)">boolean</span> transportClient, List&lt;NetworkPlugin&gt;<span style="color: rgba(0, 0, 0, 1)"> plugins, ThreadPool threadPool,
                         BigArrays bigArrays,
                         PageCacheRecycler pageCacheRecycler,
                         CircuitBreakerService circuitBreakerService,
                         NamedWriteableRegistry namedWriteableRegistry,
                         NamedXContentRegistry xContentRegistry,
                         NetworkService networkService, HttpServerTransport.Dispatcher dispatcher,
                         ClusterSettings clusterSettings) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.settings =<span style="color: rgba(0, 0, 0, 1)"> settings;
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.transportClient =<span style="color: rgba(0, 0, 0, 1)"> transportClient;
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 这里的 plugin 可能有多个，如 XPackPlugin, Netty4Plugin, Security, VotingOnlyNodePlugin</span>
        <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (NetworkPlugin plugin : plugins) {
            Map</span>&lt;String, Supplier&lt;HttpServerTransport&gt;&gt; httpTransportFactory =<span style="color: rgba(0, 0, 0, 1)"> plugin.getHttpTransports(settings, threadPool, bigArrays,
                pageCacheRecycler, circuitBreakerService, xContentRegistry, networkService, dispatcher, clusterSettings);
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (transportClient == <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">for</span> (Map.Entry&lt;String, Supplier&lt;HttpServerTransport&gt;&gt;<span style="color: rgba(0, 0, 0, 1)"> entry : httpTransportFactory.entrySet()) {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 向 transportHttpFactories 中注册相关信息</span>
<span style="color: rgba(0, 0, 0, 1)">                    registerHttpTransport(entry.getKey(), entry.getValue());
                }
            }
            Map</span>&lt;String, Supplier&lt;Transport&gt;&gt; transportFactory =<span style="color: rgba(0, 0, 0, 1)"> plugin.getTransports(settings, threadPool, pageCacheRecycler,
                circuitBreakerService, namedWriteableRegistry, networkService);
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> (Map.Entry&lt;String, Supplier&lt;Transport&gt;&gt;<span style="color: rgba(0, 0, 0, 1)"> entry : transportFactory.entrySet()) {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 向 transportFactories 中注册相关信息</span>
<span style="color: rgba(0, 0, 0, 1)">                registerTransport(entry.getKey(), entry.getValue());
            }
            List</span>&lt;TransportInterceptor&gt; transportInterceptors =<span style="color: rgba(0, 0, 0, 1)"> plugin.getTransportInterceptors(namedWriteableRegistry,
                threadPool.getThreadContext());
            </span><span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (TransportInterceptor interceptor : transportInterceptors) {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 向 transportIntercetors 中注册拦截器</span>
<span style="color: rgba(0, 0, 0, 1)">                registerTransportInterceptor(interceptor);
            }
        }
    }</span></pre>
</div>
<p>　　可见，整个 NetworkModule 的工作，重点在于注册相关的组件到自身，以便将来取用。这个容器则有可能是 map 形式的，也有可能是 list 形式的。总之，能够起到注册的作用即可。感兴趣的同学可以展开以下查看更多注册实现：</p>
<div class="cnblogs_code"><img src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" id="code_img_closed_490b126a-f366-4e16-9895-53e3baa5920b" class="code_img_closed"><img src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" id="code_img_opened_490b126a-f366-4e16-9895-53e3baa5920b" class="code_img_opened" style="display: none">
<div id="cnblogs_code_open_490b126a-f366-4e16-9895-53e3baa5920b" class="cnblogs_code_hide">
<pre>    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Map&lt;String, Supplier&lt;Transport&gt;&gt; transportFactories = <span style="color: rgba(0, 0, 255, 1)">new</span> HashMap&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> Map&lt;String, Supplier&lt;HttpServerTransport&gt;&gt; transportHttpFactories = <span style="color: rgba(0, 0, 255, 1)">new</span> HashMap&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
    </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> List&lt;TransportInterceptor&gt; transportIntercetors = <span style="color: rgba(0, 0, 255, 1)">new</span> ArrayList&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();

    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)"> Adds an http transport implementation that can be selected by setting {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> #HTTP_TYPE_KEY}. </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> TODO: we need another name than "http transport"....so confusing with transportClient...</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span> registerHttpTransport(String key, Supplier&lt;HttpServerTransport&gt;<span style="color: rgba(0, 0, 0, 1)"> factory) {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (transportClient) {
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> IllegalArgumentException("Cannot register http transport " + key + " for transport client"<span style="color: rgba(0, 0, 0, 1)">);
        }
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (transportHttpFactories.putIfAbsent(key, factory) != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> IllegalArgumentException("transport for name: " + key + " is already registered"<span style="color: rgba(0, 0, 0, 1)">);
        }
    }
    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)"> Adds a transport implementation that can be selected by setting {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> #TRANSPORT_TYPE_KEY}. </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span> registerTransport(String key, Supplier&lt;Transport&gt;<span style="color: rgba(0, 0, 0, 1)"> factory) {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (transportFactories.putIfAbsent(key, factory) != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> IllegalArgumentException("transport for name: " + key + " is already registered"<span style="color: rgba(0, 0, 0, 1)">);
        }
    }

    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * Registers a new {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> TransportInterceptor}
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> registerTransportInterceptor(TransportInterceptor interceptor) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.transportIntercetors.add(Objects.requireNonNull(interceptor, "interceptor must not be null"<span style="color: rgba(0, 0, 0, 1)">));
    }</span></pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<p>　　当然了，还有很重要的东西，就是 NetworkPlugin 中的方法的实现。因为所有的注册来源，都是基于这些方法的。这也就为我们的 plugin 提供了方便的入口，我们先来看看ES都会 NetworkPlugin 提供了哪些入口：</p>
<div class="cnblogs_code">
<pre><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.plugins</span><span style="color: rgba(0, 128, 0, 1)">
/**</span><span style="color: rgba(0, 128, 0, 1)">
 * Plugin for extending network and transport related classes
 </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
<span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">interface</span><span style="color: rgba(0, 0, 0, 1)"> NetworkPlugin {

    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * Returns a list of {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> TransportInterceptor} instances that are used to intercept incoming and outgoing
     * transport (inter-node) requests. This must not return &lt;code&gt;null&lt;/code&gt;
     *
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> namedWriteableRegistry registry of all named writeables registered
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> threadContext a {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> ThreadContext} of the current nodes or clients {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> ThreadPool} that can be used to set additional
     *                      headers in the interceptors
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">default</span> List&lt;TransportInterceptor&gt;<span style="color: rgba(0, 0, 0, 1)"> getTransportInterceptors(NamedWriteableRegistry namedWriteableRegistry,
                                                                ThreadContext threadContext) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> Collections.emptyList();
    }

    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * Returns a map of {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> Transport} suppliers.
     * See {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.common.network.NetworkModule#TRANSPORT_TYPE_KEY} to configure a specific implementation.
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">default</span> Map&lt;String, Supplier&lt;Transport&gt;&gt;<span style="color: rgba(0, 0, 0, 1)"> getTransports(Settings settings, ThreadPool threadPool, PageCacheRecycler pageCacheRecycler,
                                                           CircuitBreakerService circuitBreakerService,
                                                           NamedWriteableRegistry namedWriteableRegistry, NetworkService networkService) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> Collections.emptyMap();
    }

    </span><span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * Returns a map of {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> HttpServerTransport} suppliers.
     * See {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.common.network.NetworkModule#HTTP_TYPE_SETTING} to configure a specific implementation.
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">default</span> Map&lt;String, Supplier&lt;HttpServerTransport&gt;&gt;<span style="color: rgba(0, 0, 0, 1)"> getHttpTransports(Settings settings, ThreadPool threadPool, BigArrays bigArrays,
                                                                         PageCacheRecycler pageCacheRecycler,
                                                                         CircuitBreakerService circuitBreakerService,
                                                                         NamedXContentRegistry xContentRegistry,
                                                                         NetworkService networkService,
                                                                         HttpServerTransport.Dispatcher dispatcher,
                                                                         ClusterSettings clusterSettings) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> Collections.emptyMap();
    }
}</span></pre>
</div>
<p>　　方法不多，刚好够前面的 NetworkModule 初始化场景用。且都有默认实现方法，即如果相应plugin不关注这块东西，就直接忽略即可。</p>
<p>　　因为我们是冲着es的高性能服务来的，所以有必要看看netty的相关实现。netty中，将实现了两个获取 transport 的方法，而拦截器都未做处理，因为业务处理框架有需要。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.Netty4Plugin#getTransports</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> Map&lt;String, Supplier&lt;Transport&gt;&gt;<span style="color: rgba(0, 0, 0, 1)"> getTransports(Settings settings, ThreadPool threadPool, PageCacheRecycler pageCacheRecycler,
                                                          CircuitBreakerService circuitBreakerService,
                                                          NamedWriteableRegistry namedWriteableRegistry, NetworkService networkService) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> Collections.singletonMap(NETTY_TRANSPORT_NAME, () -&gt; <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Netty4Transport(settings, Version.CURRENT, threadPool,
            networkService, pageCacheRecycler, namedWriteableRegistry, circuitBreakerService, getSharedGroupFactory(settings)));
    }

    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> Map&lt;String, Supplier&lt;HttpServerTransport&gt;&gt;<span style="color: rgba(0, 0, 0, 1)"> getHttpTransports(Settings settings, ThreadPool threadPool, BigArrays bigArrays,
                                                                        PageCacheRecycler pageCacheRecycler,
                                                                        CircuitBreakerService circuitBreakerService,
                                                                        NamedXContentRegistry xContentRegistry,
                                                                        NetworkService networkService,
                                                                        HttpServerTransport.Dispatcher dispatcher,
                                                                        ClusterSettings clusterSettings) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> Collections.singletonMap(NETTY_HTTP_TRANSPORT_NAME,
            () </span>-&gt; <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Netty4HttpServerTransport(settings, networkService, bigArrays, threadPool, xContentRegistry, dispatcher,
                clusterSettings, getSharedGroupFactory(settings)));
    }</span></pre>
</div>
<p>　　无它，返回两个Netty相关的服务实例，备用。</p>
<p>&nbsp;</p>
<h4>2.2. transportService 的实例化</h4>
<p>　　上一节只是讲一些必要条件，本节才讲真正的初始化的逻辑。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.node.Node#newTransportService</span>
    <span style="color: rgba(0, 0, 255, 1)">protected</span><span style="color: rgba(0, 0, 0, 1)"> TransportService newTransportService(Settings settings, Transport transport, ThreadPool threadPool,
                                                   TransportInterceptor interceptor,
                                                   Function</span>&lt;BoundTransportAddress, DiscoveryNode&gt;<span style="color: rgba(0, 0, 0, 1)"> localNodeFactory,
                                                   ClusterSettings clusterSettings, Set</span>&lt;String&gt;<span style="color: rgba(0, 0, 0, 1)"> taskHeaders) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> TransportService(settings, transport, threadPool, interceptor, localNodeFactory, clusterSettings, taskHeaders);
    }</span></pre>
</div>
<p>　　没有多余的，TransportService 就是一个完整的实现类。看一下其构建方法即可。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.TransportService#TransportService</span>
    <span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * Build the service.
     *
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> clusterSettings if non null, the {</span><span style="color: rgba(128, 128, 128, 1)">@linkplain</span><span style="color: rgba(0, 128, 0, 1)"> TransportService} will register with the {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> ClusterSettings} for settings
     *    updates for {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> TransportSettings#TRACE_LOG_EXCLUDE_SETTING} and {</span><span style="color: rgba(128, 128, 128, 1)">@link</span><span style="color: rgba(0, 128, 0, 1)"> TransportSettings#TRACE_LOG_INCLUDE_SETTING}.
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> TransportService(Settings settings, Transport transport, ThreadPool threadPool, TransportInterceptor transportInterceptor,
                            Function</span>&lt;BoundTransportAddress, DiscoveryNode&gt;<span style="color: rgba(0, 0, 0, 1)"> localNodeFactory, @Nullable ClusterSettings clusterSettings,
                            Set</span>&lt;String&gt;<span style="color: rgba(0, 0, 0, 1)"> taskHeaders) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> ClusterConnectionManager 重要</span>
        <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">(settings, transport, threadPool, transportInterceptor, localNodeFactory, clusterSettings, taskHeaders,
            </span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ClusterConnectionManager(settings, transport));
    }
    
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> TransportService(Settings settings, Transport transport, ThreadPool threadPool, TransportInterceptor transportInterceptor,
                            Function</span>&lt;BoundTransportAddress, DiscoveryNode&gt;<span style="color: rgba(0, 0, 0, 1)"> localNodeFactory, @Nullable ClusterSettings clusterSettings,
                            Set</span>&lt;String&gt;<span style="color: rgba(0, 0, 0, 1)"> taskHeaders, ConnectionManager connectionManager) {

        </span><span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">boolean</span> isTransportClient =<span style="color: rgba(0, 0, 0, 1)"> TransportClient.CLIENT_TYPE.equals(settings.get(Client.CLIENT_TYPE_SETTING_S.getKey()));

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> If we are a transport client then we skip the check that the remote node has a compatible build hash</span>
        <span style="color: rgba(0, 0, 255, 1)">this</span>.requireCompatibleBuild = isTransportClient == <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> The only time we do not want to validate node connections is when this is a transport client using the simple node sampler</span>
        <span style="color: rgba(0, 0, 255, 1)">this</span>.validateConnections = isTransportClient == <span style="color: rgba(0, 0, 255, 1)">false</span> ||<span style="color: rgba(0, 0, 0, 1)"> TransportClient.CLIENT_TRANSPORT_SNIFF.get(settings);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 保存各配置及服务上下文</span>
        <span style="color: rgba(0, 0, 255, 1)">this</span>.transport =<span style="color: rgba(0, 0, 0, 1)"> transport;
        transport.setSlowLogThreshold(TransportSettings.SLOW_OPERATION_THRESHOLD_SETTING.get(settings));
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.threadPool =<span style="color: rgba(0, 0, 0, 1)"> threadPool;
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.localNodeFactory =<span style="color: rgba(0, 0, 0, 1)"> localNodeFactory;
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.connectionManager =<span style="color: rgba(0, 0, 0, 1)"> connectionManager;
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.clusterName =<span style="color: rgba(0, 0, 0, 1)"> ClusterName.CLUSTER_NAME_SETTING.get(settings);
        setTracerLogInclude(TransportSettings.TRACE_LOG_INCLUDE_SETTING.get(settings));
        setTracerLogExclude(TransportSettings.TRACE_LOG_EXCLUDE_SETTING.get(settings));
        tracerLog </span>= Loggers.getLogger(logger, ".tracer"<span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 任务管理器</span>
        taskManager =<span style="color: rgba(0, 0, 0, 1)"> createTaskManager(settings, threadPool, taskHeaders);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 拦截器获取</span>
        <span style="color: rgba(0, 0, 255, 1)">this</span>.interceptor =<span style="color: rgba(0, 0, 0, 1)"> transportInterceptor;
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.asyncSender = interceptor.interceptSender(<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">::sendRequestInternal);
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.remoteClusterClient =<span style="color: rgba(0, 0, 0, 1)"> DiscoveryNode.isRemoteClusterClient(settings);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 集群服务管理</span>
        remoteClusterService = <span style="color: rgba(0, 0, 255, 1)">new</span> RemoteClusterService(settings, <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">);
        responseHandlers </span>=<span style="color: rgba(0, 0, 0, 1)"> transport.getResponseHandlers();
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (clusterSettings != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
            clusterSettings.addSettingsUpdateConsumer(TransportSettings.TRACE_LOG_INCLUDE_SETTING, </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">::setTracerLogInclude);
            clusterSettings.addSettingsUpdateConsumer(TransportSettings.TRACE_LOG_EXCLUDE_SETTING, </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">::setTracerLogExclude);
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (remoteClusterClient) {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 监听配置更新操作</span>
<span style="color: rgba(0, 0, 0, 1)">                remoteClusterService.listenForUpdates(clusterSettings);
            }
            clusterSettings.addSettingsUpdateConsumer(TransportSettings.SLOW_OPERATION_THRESHOLD_SETTING, transport::setSlowLogThreshold);
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 注册握手方法的处理器 internal:transport/handshake</span>
<span style="color: rgba(0, 0, 0, 1)">        registerRequestHandler(
            HANDSHAKE_ACTION_NAME,
            ThreadPool.Names.SAME,
            </span><span style="color: rgba(0, 0, 255, 1)">false</span>, <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">,
            HandshakeRequest::</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)">,
            (request, channel, task) </span>-&gt;<span style="color: rgba(0, 0, 0, 1)"> channel.sendResponse(
                </span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HandshakeResponse(localNode.getVersion(), Build.CURRENT.hash(), localNode, clusterName)));

        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (PERMIT_HANDSHAKES_FROM_INCOMPATIBLE_BUILDS) {
            logger.warn(</span>"transport handshakes from incompatible builds are unsafely permitted on this node; remove system property [" +<span style="color: rgba(0, 0, 0, 1)">
                    PERMIT_HANDSHAKES_FROM_INCOMPATIBLE_BUILDS_KEY </span>+ "] to resolve this warning"<span style="color: rgba(0, 0, 0, 1)">);
            DeprecationLogger.getLogger(TransportService.</span><span style="color: rgba(0, 0, 255, 1)">class</span>).deprecate("permit_handshake_from_incompatible_builds"<span style="color: rgba(0, 0, 0, 1)">,
                </span>"system property [" + PERMIT_HANDSHAKES_FROM_INCOMPATIBLE_BUILDS_KEY + "] is deprecated and should be removed"<span style="color: rgba(0, 0, 0, 1)">);
        }
    }</span></pre>
</div>
<p>　　无它，就是实例化各种必要的服务，保存必要配置信息。其中每个点都值得去深挖，但这不是我们的目的。我们只需了解大致即可。不过有一个 ClusterConnectionManager 还是需要我们重视，因为它的作用是维持和集群各节点通信的特性，此处实例化后，后面将会被完美利用。实例化时，更多的是保存 transport 实例，以便真正实现远程连接。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.ClusterConnectionManager#ClusterConnectionManager</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> ClusterConnectionManager(Settings settings, Transport transport) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">(ConnectionProfile.buildDefaultConnectionProfile(settings), transport);
    }

    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> ClusterConnectionManager(ConnectionProfile connectionProfile, Transport transport) {
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.transport =<span style="color: rgba(0, 0, 0, 1)"> transport;
        </span><span style="color: rgba(0, 0, 255, 1)">this</span>.defaultProfile =<span style="color: rgba(0, 0, 0, 1)"> connectionProfile;
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.ConnectionProfile#buildDefaultConnectionProfile</span>
    <span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * Builds a default connection profile based on the provided settings.
     *
     * </span><span style="color: rgba(128, 128, 128, 1)">@param</span><span style="color: rgba(0, 128, 0, 1)"> settings to build the connection profile from
     * </span><span style="color: rgba(128, 128, 128, 1)">@return</span><span style="color: rgba(0, 128, 0, 1)"> the connection profile
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">static</span><span style="color: rgba(0, 0, 0, 1)"> ConnectionProfile buildDefaultConnectionProfile(Settings settings) {
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> connectionsPerNodeRecovery =<span style="color: rgba(0, 0, 0, 1)"> TransportSettings.CONNECTIONS_PER_NODE_RECOVERY.get(settings);
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> connectionsPerNodeBulk =<span style="color: rgba(0, 0, 0, 1)"> TransportSettings.CONNECTIONS_PER_NODE_BULK.get(settings);
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> connectionsPerNodeReg =<span style="color: rgba(0, 0, 0, 1)"> TransportSettings.CONNECTIONS_PER_NODE_REG.get(settings);
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> connectionsPerNodeState =<span style="color: rgba(0, 0, 0, 1)"> TransportSettings.CONNECTIONS_PER_NODE_STATE.get(settings);
        </span><span style="color: rgba(0, 0, 255, 1)">int</span> connectionsPerNodePing =<span style="color: rgba(0, 0, 0, 1)"> TransportSettings.CONNECTIONS_PER_NODE_PING.get(settings);
        Builder builder </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Builder();
        builder.setConnectTimeout(TransportSettings.CONNECT_TIMEOUT.get(settings));
        builder.setHandshakeTimeout(TransportSettings.CONNECT_TIMEOUT.get(settings));
        builder.setPingInterval(TransportSettings.PING_SCHEDULE.get(settings));
        builder.setCompressionEnabled(TransportSettings.TRANSPORT_COMPRESS.get(settings));
        builder.addConnections(connectionsPerNodeBulk, TransportRequestOptions.Type.BULK);
        builder.addConnections(connectionsPerNodePing, TransportRequestOptions.Type.PING);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> if we are not master eligible we don't need a dedicated channel to publish the state</span>
        builder.addConnections(DiscoveryNode.isMasterNode(settings) ? connectionsPerNodeState : 0<span style="color: rgba(0, 0, 0, 1)">, TransportRequestOptions.Type.STATE);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> if we are not a data-node we don't need any dedicated channels for recovery</span>
        builder.addConnections(DiscoveryNode.isDataNode(settings) ? connectionsPerNodeRecovery : 0<span style="color: rgba(0, 0, 0, 1)">, TransportRequestOptions.Type.RECOVERY);
        builder.addConnections(connectionsPerNodeReg, TransportRequestOptions.Type.REG);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> builder.build();
    }</span></pre>
</div>
<p>　　到此，整个 transportService 的实例化工作就算是完成了。至于其何真正work起来，则需要留到整个es框架的start的生命周期节点时才会体现。且看下节分解。</p>
<p>&nbsp;</p>
<h3>3. transportService的启动核心</h3>
<p>　　即它是如何开始工作的，以及它的工作模式是怎么样的？</p>
<p>　　事实上，整个ES的框架，是一个生命周期管理模式存在的。而它的所有组件真正的启动时机，也是在start() 周期中统一进行的的。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.node.Node#start</span>
    <span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * Start the node. If the node is already started, this method is no-op.
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> Node start() <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> NodeValidationException {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">lifecycle.moveToStarted()) {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">;
        }

        logger.info(</span>"starting ..."<span style="color: rgba(0, 0, 0, 1)">);
        pluginLifecycleComponents.forEach(LifecycleComponent::start);
        ...
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Start the transport service now so the publish address will be added to the local disco node in ClusterService
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取 transportService 实例</span>
        TransportService transportService = injector.getInstance(TransportService.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置 taskManager 的两个任务管理器</span>
        transportService.getTaskManager().setTaskResultsService(injector.getInstance(TaskResultsService.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">));
        transportService.getTaskManager().setTaskCancellationService(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> TaskCancellationService(transportService));
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> transportService 生命周期开始</span>
<span style="color: rgba(0, 0, 0, 1)">        transportService.start();
        </span><span style="color: rgba(0, 0, 255, 1)">assert</span> localNodeFactory.getNode() != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">assert</span><span style="color: rgba(0, 0, 0, 1)"> transportService.getLocalNode().equals(localNodeFactory.getNode())
            : </span>"transportService has a different local node than the factory provided"<span style="color: rgba(0, 0, 0, 1)">;
        injector.getInstance(PeerRecoverySourceService.</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">).start();
        ...
        logger.info(</span>"started"<span style="color: rgba(0, 0, 0, 1)">);

        pluginsService.filterPlugins(ClusterPlugin.</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">).forEach(ClusterPlugin::onNodeStarted);

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">;
    }</span></pre>
</div>
<p>　　在该周期内，要处理的组件非常多，而我们则只挑关注点：transportService 的初始化，一窥其行为。其过程主要为，通过injector获取前面实例化的 transportService, 然后设置taskManager的必要属性, 最后调用transportService的start()方法，开启真正的服务。</p>
<p>　　即核心就是 transportService.start() , 这是一个统一的生命周期入口方法:</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.common.component.AbstractLifecycleComponent#start</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> start() {
        </span><span style="color: rgba(0, 0, 255, 1)">synchronized</span><span style="color: rgba(0, 0, 0, 1)"> (lifecycle) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 安全启动，不允许重复初始化，或者其他</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">lifecycle.canMoveToStarted()) {
                </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)">;
            }
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 监听者处理</span>
            <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (LifecycleListener listener : listeners) {
                listener.beforeStart();
            }
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 各真实组件完成必要任务的地方</span>
<span style="color: rgba(0, 0, 0, 1)">            doStart();
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置状态为已启动，为下次判断做好依据</span>
<span style="color: rgba(0, 0, 0, 1)">            lifecycle.moveToStarted();
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 后置监听</span>
            <span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (LifecycleListener listener : listeners) {
                listener.afterStart();
            }
        }
    }</span></pre>
</div>
<p>　　这一生命周期管理，可以非常完整了。首先，它是线程安全的，然后不允许重复初始化或在不必要的时候初始化，然后还有前置和后置监听钩子供用户扩展。监听处理自不必多说，但如何管理组件的状态，可以一起看看：</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.common.component.Lifecycle#canMoveToStarted</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">boolean</span> canMoveToStarted() <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> IllegalStateException {
        State localState </span>= <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.state;
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (localState == State.INITIALIZED || localState ==<span style="color: rgba(0, 0, 0, 1)"> State.STOPPED) {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (localState ==<span style="color: rgba(0, 0, 0, 1)"> State.STARTED) {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (localState ==<span style="color: rgba(0, 0, 0, 1)"> State.CLOSED) {
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> IllegalStateException("Can't move to started state when closed"<span style="color: rgba(0, 0, 0, 1)">);
        }
        </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> IllegalStateException("Can't move to started with unknown state"<span style="color: rgba(0, 0, 0, 1)">);
    }
    
    </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">synchronized</span> <span style="color: rgba(0, 0, 255, 1)">boolean</span> moveToStarted() <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> IllegalStateException {
        State localState </span>= <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.state;
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (localState == State.INITIALIZED || localState ==<span style="color: rgba(0, 0, 0, 1)"> State.STOPPED) {
            state </span>=<span style="color: rgba(0, 0, 0, 1)"> State.STARTED;
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (localState ==<span style="color: rgba(0, 0, 0, 1)"> State.STARTED) {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
        }
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (localState ==<span style="color: rgba(0, 0, 0, 1)"> State.CLOSED) {
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> IllegalStateException("Can't move to started state when closed"<span style="color: rgba(0, 0, 0, 1)">);
        }
        </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> IllegalStateException("Can't move to started with unknown state"<span style="color: rgba(0, 0, 0, 1)">);
    }</span></pre>
</div>
<p>　　状态判定，一切尽在代码中。</p>
<p>　　接下来，是我们真正的 transportService 的启动实现了。即 transport.doStart() 方法：</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.TransportService#doStart</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> doStart() {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> transport 先start</span>
        transport.setMessageListener(<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">);
        connectionManager.addListener(</span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">);
        transport.start();
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (transport.boundAddress() != <span style="color: rgba(0, 0, 255, 1)">null</span> &amp;&amp;<span style="color: rgba(0, 0, 0, 1)"> logger.isInfoEnabled()) {
            logger.info(</span>"{}"<span style="color: rgba(0, 0, 0, 1)">, transport.boundAddress());
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> (Map.Entry&lt;String, BoundTransportAddress&gt;<span style="color: rgba(0, 0, 0, 1)"> entry : transport.profileBoundAddresses().entrySet()) {
                logger.info(</span>"profile [{}]: {}"<span style="color: rgba(0, 0, 0, 1)">, entry.getKey(), entry.getValue());
            }
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置本地节点标识</span>
        localNode =<span style="color: rgba(0, 0, 0, 1)"> localNodeFactory.apply(transport.boundAddress());
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 连接到集群</span>
        <span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (remoteClusterClient) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> here we start to connect to the remote clusters</span>
<span style="color: rgba(0, 0, 0, 1)">            remoteClusterService.initializeRemoteClusters();
        }
    }</span></pre>
</div>
<p>　　以上 transportService.doStart(), 看起来并没有实际什么工作，而只是将start()又交给了 transport 组件了。而 transportService 只是一些前置和后置工作。也难怪，transport 承担着各节点的连接能力，由其进行真正的网络通信启动，再合适不过了。</p>
<p>　　而同样的，transport 也是一个受ES生命周期管理的组件，如同前面我们看到的一样的，它会再执行一遍。只是此时，它拥有了更多的监听器了。而它的 doStart() 则体现了其工作过程。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.xpack.security.transport.netty4.SecurityNetty4ServerTransport#doStart</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> doStart() {
        </span><span style="color: rgba(0, 0, 255, 1)">super</span><span style="color: rgba(0, 0, 0, 1)">.doStart();
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (authenticator != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
            authenticator.setBoundTransportAddress(boundAddress(), profileBoundAddresses());
        }
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.xpack.core.security.transport.netty4.SecurityNetty4Transport#doStart</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> doStart() {
        </span><span style="color: rgba(0, 0, 255, 1)">super</span><span style="color: rgba(0, 0, 0, 1)">.doStart();
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.netty4.Netty4Transport#doStart</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> doStart() {
        </span><span style="color: rgba(0, 0, 255, 1)">boolean</span> success = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取 netty 的 eventGroup, 复用目的</span>
            sharedGroup =<span style="color: rgba(0, 0, 0, 1)"> sharedGroupFactory.getTransportGroup();
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 创建 bootstrap, client 版本</span>
            clientBootstrap =<span style="color: rgba(0, 0, 0, 1)"> createClientBootstrap(sharedGroup);
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (NetworkService.NETWORK_SERVER.get(settings)) {
                </span><span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (ProfileSettings profileSettings : profileSettings) {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 创建 bootsrap, server 版本</span>
<span style="color: rgba(0, 0, 0, 1)">                    createServerBootstrap(profileSettings, sharedGroup);
                    bindServer(profileSettings);
                }
            }
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> TcpTransport 默认为空 </span>
            <span style="color: rgba(0, 0, 255, 1)">super</span><span style="color: rgba(0, 0, 0, 1)">.doStart();
            success </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
        } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (success == <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">) {
                doStop();
            }
        }
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.netty4.Netty4Transport#createClientBootstrap</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span><span style="color: rgba(0, 0, 0, 1)"> Bootstrap createClientBootstrap(SharedGroupFactory.SharedGroup sharedGroup) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> netty 的 bootsrap 的创建过程，编程范式而已
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置各可控参数</span>
        <span style="color: rgba(0, 0, 255, 1)">final</span> Bootstrap bootstrap = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Bootstrap();
        bootstrap.group(sharedGroup.getLowLevelGroup());

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> NettyAllocator will return the channel type designed to work with the configured allocator</span>
        <span style="color: rgba(0, 0, 255, 1)">assert</span> Netty4NioSocketChannel.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">.isAssignableFrom(NettyAllocator.getChannelType());
        bootstrap.channel(NettyAllocator.getChannelType());
        bootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());

        bootstrap.option(ChannelOption.TCP_NODELAY, TransportSettings.TCP_NO_DELAY.get(settings));
        bootstrap.option(ChannelOption.SO_KEEPALIVE, TransportSettings.TCP_KEEP_ALIVE.get(settings));
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (TransportSettings.TCP_KEEP_ALIVE.get(settings)) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Note that Netty logs a warning if it can't set the option</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (TransportSettings.TCP_KEEP_IDLE.get(settings) &gt;= 0<span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">final</span> SocketOption&lt;Integer&gt; keepIdleOption =<span style="color: rgba(0, 0, 0, 1)"> NetUtils.getTcpKeepIdleSocketOptionOrNull();
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (keepIdleOption != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                    bootstrap.option(NioChannelOption.of(keepIdleOption), TransportSettings.TCP_KEEP_IDLE.get(settings));
                }
            }
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (TransportSettings.TCP_KEEP_INTERVAL.get(settings) &gt;= 0<span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">final</span> SocketOption&lt;Integer&gt; keepIntervalOption =<span style="color: rgba(0, 0, 0, 1)"> NetUtils.getTcpKeepIntervalSocketOptionOrNull();
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (keepIntervalOption != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                    bootstrap.option(NioChannelOption.of(keepIntervalOption), TransportSettings.TCP_KEEP_INTERVAL.get(settings));
                }
            }
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (TransportSettings.TCP_KEEP_COUNT.get(settings) &gt;= 0<span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">final</span> SocketOption&lt;Integer&gt; keepCountOption =<span style="color: rgba(0, 0, 0, 1)"> NetUtils.getTcpKeepCountSocketOptionOrNull();
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (keepCountOption != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                    bootstrap.option(NioChannelOption.of(keepCountOption), TransportSettings.TCP_KEEP_COUNT.get(settings));
                }
            }
        }

        </span><span style="color: rgba(0, 0, 255, 1)">final</span> ByteSizeValue tcpSendBufferSize =<span style="color: rgba(0, 0, 0, 1)"> TransportSettings.TCP_SEND_BUFFER_SIZE.get(settings);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (tcpSendBufferSize.getBytes() &gt; 0<span style="color: rgba(0, 0, 0, 1)">) {
            bootstrap.option(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));
        }

        </span><span style="color: rgba(0, 0, 255, 1)">final</span> ByteSizeValue tcpReceiveBufferSize =<span style="color: rgba(0, 0, 0, 1)"> TransportSettings.TCP_RECEIVE_BUFFER_SIZE.get(settings);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (tcpReceiveBufferSize.getBytes() &gt; 0<span style="color: rgba(0, 0, 0, 1)">) {
            bootstrap.option(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));
        }

        bootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);

        </span><span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">boolean</span> reuseAddress =<span style="color: rgba(0, 0, 0, 1)"> TransportSettings.TCP_REUSE_ADDRESS.get(settings);
        bootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);

        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> bootstrap;
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.netty4.Netty4Transport#createServerBootstrap</span>
    <span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> createServerBootstrap(ProfileSettings profileSettings, SharedGroupFactory.SharedGroup sharedGroup) {
        String name </span>=<span style="color: rgba(0, 0, 0, 1)"> profileSettings.profileName;
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (logger.isDebugEnabled()) {
            logger.debug(</span>"using profile[{}], worker_count[{}], port[{}], bind_host[{}], publish_host[{}], receive_predictor[{}-&gt;{}]"<span style="color: rgba(0, 0, 0, 1)">,
                name, sharedGroupFactory.getTransportWorkerCount(), profileSettings.portOrRange, profileSettings.bindHosts,
                profileSettings.publishHosts, receivePredictorMin, receivePredictorMax);
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> serverBootstrap 的编程范式</span>
        <span style="color: rgba(0, 0, 255, 1)">final</span> ServerBootstrap serverBootstrap = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ServerBootstrap();

        serverBootstrap.group(sharedGroup.getLowLevelGroup());

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> NettyAllocator will return the channel type designed to work with the configuredAllocator</span>
<span style="color: rgba(0, 0, 0, 1)">        serverBootstrap.channel(NettyAllocator.getServerChannelType());

        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Set the allocators for both the server channel and the child channels created</span>
<span style="color: rgba(0, 0, 0, 1)">        serverBootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());
        serverBootstrap.childOption(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置handler, 未来数据处理入口从此入</span>
<span style="color: rgba(0, 0, 0, 1)">        serverBootstrap.childHandler(getServerChannelInitializer(name));
        serverBootstrap.handler(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ServerChannelExceptionHandler());

        serverBootstrap.childOption(ChannelOption.TCP_NODELAY, profileSettings.tcpNoDelay);
        serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, profileSettings.tcpKeepAlive);
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (profileSettings.tcpKeepAlive) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Note that Netty logs a warning if it can't set the option</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (profileSettings.tcpKeepIdle &gt;= 0<span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">final</span> SocketOption&lt;Integer&gt; keepIdleOption =<span style="color: rgba(0, 0, 0, 1)"> NetUtils.getTcpKeepIdleSocketOptionOrNull();
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (keepIdleOption != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                    serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), profileSettings.tcpKeepIdle);
                }
            }
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (profileSettings.tcpKeepInterval &gt;= 0<span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">final</span> SocketOption&lt;Integer&gt; keepIntervalOption =<span style="color: rgba(0, 0, 0, 1)"> NetUtils.getTcpKeepIntervalSocketOptionOrNull();
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (keepIntervalOption != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                    serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption), profileSettings.tcpKeepInterval);
                }

            }
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (profileSettings.tcpKeepCount &gt;= 0<span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">final</span> SocketOption&lt;Integer&gt; keepCountOption =<span style="color: rgba(0, 0, 0, 1)"> NetUtils.getTcpKeepCountSocketOptionOrNull();
                </span><span style="color: rgba(0, 0, 255, 1)">if</span> (keepCountOption != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                    serverBootstrap.childOption(NioChannelOption.of(keepCountOption), profileSettings.tcpKeepCount);
                }
            }
        }

        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (profileSettings.sendBufferSize.getBytes() != -1<span style="color: rgba(0, 0, 0, 1)">) {
            serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(profileSettings.sendBufferSize.getBytes()));
        }

        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (profileSettings.receiveBufferSize.getBytes() != -1<span style="color: rgba(0, 0, 0, 1)">) {
            serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(profileSettings.receiveBufferSize.bytesAsInt()));
        }

        serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);
        serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);

        serverBootstrap.option(ChannelOption.SO_REUSEADDR, profileSettings.reuseAddress);
        serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, profileSettings.reuseAddress);
        serverBootstrap.validate();

        serverBootstraps.put(name, serverBootstrap);
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.netty4.Netty4Transport#getServerChannelInitializer</span>
    <span style="color: rgba(0, 0, 255, 1)">protected</span><span style="color: rgba(0, 0, 0, 1)"> ChannelHandler getServerChannelInitializer(String name) {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ServerChannelInitializer(name);
    }
    
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">class</span> ServerChannelInitializer <span style="color: rgba(0, 0, 255, 1)">extends</span> ChannelInitializer&lt;Channel&gt;<span style="color: rgba(0, 0, 0, 1)"> {

        </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> String name;
        </span><span style="color: rgba(0, 0, 255, 1)">private</span> <span style="color: rgba(0, 0, 255, 1)">final</span> NettyByteBufSizer sizer = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> NettyByteBufSizer();

        </span><span style="color: rgba(0, 0, 255, 1)">protected</span><span style="color: rgba(0, 0, 0, 1)"> ServerChannelInitializer(String name) {
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.name =<span style="color: rgba(0, 0, 0, 1)"> name;
        }

        @Override
        </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> initChannel(Channel ch) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
            addClosedExceptionLogger(ch);
            </span><span style="color: rgba(0, 0, 255, 1)">assert</span> ch <span style="color: rgba(0, 0, 255, 1)">instanceof</span><span style="color: rgba(0, 0, 0, 1)"> Netty4NioSocketChannel;
            NetUtils.tryEnsureReasonableKeepAliveConfig(((Netty4NioSocketChannel) ch).javaChannel());
            Netty4TcpChannel nettyTcpChannel </span>= <span style="color: rgba(0, 0, 255, 1)">new</span> Netty4TcpChannel(ch, <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">, name, ch.newSucceededFuture());
            ch.attr(CHANNEL_KEY).set(nettyTcpChannel);
            ch.pipeline().addLast(</span>"byte_buf_sizer"<span style="color: rgba(0, 0, 0, 1)">, sizer);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 通过 logging 记录请求日志</span>
            ch.pipeline().addLast("logging", <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ESLoggingHandler());
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 通过 dispatcher 分发处理请求</span>
            ch.pipeline().addLast("dispatcher", <span style="color: rgba(0, 0, 255, 1)">new</span> Netty4MessageChannelHandler(pageCacheRecycler, Netty4Transport.<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">));
            serverAcceptedChannel(nettyTcpChannel);
        }

        @Override
        </span><span style="color: rgba(0, 0, 255, 1)">public</span> <span style="color: rgba(0, 0, 255, 1)">void</span> exceptionCaught(ChannelHandlerContext ctx, Throwable cause) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
            ExceptionsHelper.maybeDieOnAnotherThread(cause);
            </span><span style="color: rgba(0, 0, 255, 1)">super</span><span style="color: rgba(0, 0, 0, 1)">.exceptionCaught(ctx, cause);
        }
    }

    bindServer 是将我们初始化好的 serverBootstrap, 绑定到某个端口上，以便其可以真正监听请求的到来。
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.TcpTransport#bindServer</span>
    <span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> bindServer(ProfileSettings profileSettings) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Bind and start to accept incoming connections.</span>
<span style="color: rgba(0, 0, 0, 1)">        InetAddress[] hostAddresses;
        List</span>&lt;String&gt; profileBindHosts =<span style="color: rgba(0, 0, 0, 1)"> profileSettings.bindHosts;
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            hostAddresses </span>=<span style="color: rgba(0, 0, 0, 1)"> networkService.resolveBindHostAddresses(profileBindHosts.toArray(Strings.EMPTY_ARRAY));
        } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (IOException e) {
            </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> BindTransportException("Failed to resolve host " +<span style="color: rgba(0, 0, 0, 1)"> profileBindHosts, e);
        }
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (logger.isDebugEnabled()) {
            String[] addresses </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> String[hostAddresses.length];
            </span><span style="color: rgba(0, 0, 255, 1)">for</span> (<span style="color: rgba(0, 0, 255, 1)">int</span> i = 0; i &lt; hostAddresses.length; i++<span style="color: rgba(0, 0, 0, 1)">) {
                addresses[i] </span>=<span style="color: rgba(0, 0, 0, 1)"> NetworkAddress.format(hostAddresses[i]);
            }
            logger.debug(</span>"binding server bootstrap to: {}"<span style="color: rgba(0, 0, 0, 1)">, (Object) addresses);
        }

        </span><span style="color: rgba(0, 0, 255, 1)">assert</span> hostAddresses.length &gt; 0<span style="color: rgba(0, 0, 0, 1)">;

        List</span>&lt;InetSocketAddress&gt; boundAddresses = <span style="color: rgba(0, 0, 255, 1)">new</span> ArrayList&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
        </span><span style="color: rgba(0, 0, 255, 1)">for</span><span style="color: rgba(0, 0, 0, 1)"> (InetAddress hostAddress : hostAddresses) {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 调用 bindToPort() 绑定端口到 serverBootstrap 上</span>
<span style="color: rgba(0, 0, 0, 1)">            boundAddresses.add(bindToPort(profileSettings.profileName, hostAddress, profileSettings.portOrRange));
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 保存已发布的端口信息</span>
        <span style="color: rgba(0, 0, 255, 1)">final</span> BoundTransportAddress boundTransportAddress =<span style="color: rgba(0, 0, 0, 1)"> createBoundTransportAddress(profileSettings, boundAddresses);

        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (profileSettings.isDefaultProfile) {
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.boundAddress =<span style="color: rgba(0, 0, 0, 1)"> boundTransportAddress;
        } </span><span style="color: rgba(0, 0, 255, 1)">else</span><span style="color: rgba(0, 0, 0, 1)"> {
            profileBoundAddresses.put(profileSettings.profileName, boundTransportAddress);
        }
    }

    </span><span style="color: rgba(0, 0, 255, 1)">private</span> InetSocketAddress bindToPort(<span style="color: rgba(0, 0, 255, 1)">final</span> String name, <span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> InetAddress hostAddress, String port) {
        PortsRange portsRange </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> PortsRange(port);
        </span><span style="color: rgba(0, 0, 255, 1)">final</span> AtomicReference&lt;Exception&gt; lastException = <span style="color: rgba(0, 0, 255, 1)">new</span> AtomicReference&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
        </span><span style="color: rgba(0, 0, 255, 1)">final</span> AtomicReference&lt;InetSocketAddress&gt; boundSocket = <span style="color: rgba(0, 0, 255, 1)">new</span> AtomicReference&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">();
        closeLock.writeLock().lock();
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> No need for locking here since Lifecycle objects can't move from STARTED to INITIALIZED</span>
            <span style="color: rgba(0, 0, 255, 1)">if</span> (lifecycle.initialized() == <span style="color: rgba(0, 0, 255, 1)">false</span> &amp;&amp; lifecycle.started() == <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">) {
                </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span> IllegalStateException("transport has been stopped"<span style="color: rgba(0, 0, 0, 1)">);
            }
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 此处将会迭代可用端口，比如从 9300-9400 依次查找可用端口，提供服务</span>
            <span style="color: rgba(0, 0, 255, 1)">boolean</span> success = portsRange.iterate(portNumber -&gt;<span style="color: rgba(0, 0, 0, 1)"> {
                </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
                    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 绑定到 serverBootstrap 中</span>
                    TcpServerChannel channel = bind(name, <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> InetSocketAddress(hostAddress, portNumber));
                    serverChannels.computeIfAbsent(name, k </span>-&gt; <span style="color: rgba(0, 0, 255, 1)">new</span> ArrayList&lt;&gt;<span style="color: rgba(0, 0, 0, 1)">()).add(channel);
                    boundSocket.set(channel.getLocalAddress());
                } </span><span style="color: rgba(0, 0, 255, 1)">catch</span><span style="color: rgba(0, 0, 0, 1)"> (Exception e) {
                    lastException.set(e);
                    </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
                }
                </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
            });
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">success) {
                </span><span style="color: rgba(0, 0, 255, 1)">throw</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> BindTransportException(
                    </span>"Failed to bind to " +<span style="color: rgba(0, 0, 0, 1)"> NetworkAddress.format(hostAddress, portsRange),
                    lastException.get()
                );
            }
        } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            closeLock.writeLock().unlock();
        }
        </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (logger.isDebugEnabled()) {
            logger.debug(</span>"Bound profile [{}] to address {{}}"<span style="color: rgba(0, 0, 0, 1)">, name, NetworkAddress.format(boundSocket.get()));
        }

        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> boundSocket.get();
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.transport.netty4.Netty4Transport#bind</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span><span style="color: rgba(0, 0, 0, 1)"> Netty4TcpServerChannel bind(String name, InetSocketAddress address) {
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 调用 netty 的端口绑定方法，到此对外服务功能开启</span>
        Channel channel =<span style="color: rgba(0, 0, 0, 1)"> serverBootstraps.get(name).bind(address).syncUninterruptibly().channel();
        Netty4TcpServerChannel esChannel </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Netty4TcpServerChannel(channel);
        channel.attr(SERVER_CHANNEL_KEY).set(esChannel);
        </span><span style="color: rgba(0, 0, 255, 1)">return</span><span style="color: rgba(0, 0, 0, 1)"> esChannel;
    }</span></pre>
</div>
<p>　　以上，就是es的transport的初始化过程了。至于后续连接或更新集群信息到其他节点，则是另一堆问题了。至少我们明白了，es是通过netty来开启服务端口，然后通过 Netty4MessageChannelHandler 来分发网络请求。</p>
<p>&nbsp;</p>
<h3>4. http请求处理器的初始化</h3>
<p>　　上面的分析中，我们看到了es对于transportService的实例化和初始化过程，大致明白了其处理网络请求的方式。但是，当我们细查时，发现以上提供的服务为9300端口的服务，而非我们常看到的 http://localhost:9200 那种。最终，再经过一番查看后，发现原来，在启动时还会有另外一个服务会被启动，那就是 HttpServerTransport , 这才是为我们提供http查询请求的服务。</p>
<p>　　其工作流程与以上过程基本一致，只是其初始化不同的 netty handler 而已。</p>
<div class="cnblogs_code">
<pre>    <span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.node.Node#start</span>
    <span style="color: rgba(0, 128, 0, 1)">/**</span><span style="color: rgba(0, 128, 0, 1)">
     * Start the node. If the node is already started, this method is no-op.
     </span><span style="color: rgba(0, 128, 0, 1)">*/</span>
    <span style="color: rgba(0, 0, 255, 1)">public</span> Node start() <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> NodeValidationException {
        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (!<span style="color: rgba(0, 0, 0, 1)">lifecycle.moveToStarted()) {
            </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">;
        }

        logger.info(</span>"starting ..."<span style="color: rgba(0, 0, 0, 1)">);
        pluginLifecycleComponents.forEach(LifecycleComponent::start);
        ...
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Start the transport service now so the publish address will be added to the local disco node in ClusterService
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 获取 transportService 实例</span>
        TransportService transportService = injector.getInstance(TransportService.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">);
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 设置 taskManager 的两个任务管理器</span>
        transportService.getTaskManager().setTaskResultsService(injector.getInstance(TaskResultsService.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">));
        transportService.getTaskManager().setTaskCancellationService(</span><span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> TaskCancellationService(transportService));
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> transportService 生命周期开始</span>
<span style="color: rgba(0, 0, 0, 1)">        transportService.start();
        </span><span style="color: rgba(0, 0, 255, 1)">assert</span> localNodeFactory.getNode() != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">assert</span><span style="color: rgba(0, 0, 0, 1)"> transportService.getLocalNode().equals(localNodeFactory.getNode())
            : </span>"transportService has a different local node than the factory provided"<span style="color: rgba(0, 0, 0, 1)">;
        injector.getInstance(PeerRecoverySourceService.</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">).start();
        ...
        
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 初始化 http 查询服务, 其对应的具体实现类是 SecurityNetty4ServerTransport </span>
        injector.getInstance(HttpServerTransport.<span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">).start();
        ...
        logger.info(</span>"started"<span style="color: rgba(0, 0, 0, 1)">);

        pluginsService.filterPlugins(ClusterPlugin.</span><span style="color: rgba(0, 0, 255, 1)">class</span><span style="color: rgba(0, 0, 0, 1)">).forEach(ClusterPlugin::onNodeStarted);

        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">;
    }

    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.xpack.security.transport.netty4.SecurityNetty4HttpServerTransport#doStart</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> doStart() {
        </span><span style="color: rgba(0, 0, 255, 1)">super</span><span style="color: rgba(0, 0, 0, 1)">.doStart();
        ipFilter.setBoundHttpTransportAddress(</span><span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">.boundAddress());
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.http.netty4.Netty4HttpServerTransport#doStart</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span><span style="color: rgba(0, 0, 0, 1)"> doStart() {
        </span><span style="color: rgba(0, 0, 255, 1)">boolean</span> success = <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">;
        </span><span style="color: rgba(0, 0, 255, 1)">try</span><span style="color: rgba(0, 0, 0, 1)"> {
            sharedGroup </span>=<span style="color: rgba(0, 0, 0, 1)"> sharedGroupFactory.getHttpGroup();
            serverBootstrap </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ServerBootstrap();

            serverBootstrap.group(sharedGroup.getLowLevelGroup());

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> NettyAllocator will return the channel type designed to work with the configuredAllocator</span>
<span style="color: rgba(0, 0, 0, 1)">            serverBootstrap.channel(NettyAllocator.getServerChannelType());

            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Set the allocators for both the server channel and the child channels created</span>
<span style="color: rgba(0, 0, 0, 1)">            serverBootstrap.option(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());
            serverBootstrap.childOption(ChannelOption.ALLOCATOR, NettyAllocator.getAllocator());
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 具体handler 的差异在此体现</span>
<span style="color: rgba(0, 0, 0, 1)">            serverBootstrap.childHandler(configureServerChannelHandler());
            serverBootstrap.handler(</span><span style="color: rgba(0, 0, 255, 1)">new</span> ServerChannelExceptionHandler(<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">));

            serverBootstrap.childOption(ChannelOption.TCP_NODELAY, SETTING_HTTP_TCP_NO_DELAY.get(settings));
            serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, SETTING_HTTP_TCP_KEEP_ALIVE.get(settings));

            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (SETTING_HTTP_TCP_KEEP_ALIVE.get(settings)) {
                </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> Netty logs a warning if it can't set the option, so try this only on supported platforms</span>
                <span style="color: rgba(0, 0, 255, 1)">if</span> (IOUtils.LINUX ||<span style="color: rgba(0, 0, 0, 1)"> IOUtils.MAC_OS_X) {
                    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (SETTING_HTTP_TCP_KEEP_IDLE.get(settings) &gt;= 0<span style="color: rgba(0, 0, 0, 1)">) {
                        </span><span style="color: rgba(0, 0, 255, 1)">final</span> SocketOption&lt;Integer&gt; keepIdleOption =<span style="color: rgba(0, 0, 0, 1)"> NetUtils.getTcpKeepIdleSocketOptionOrNull();
                        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (keepIdleOption != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                            serverBootstrap.childOption(NioChannelOption.of(keepIdleOption), SETTING_HTTP_TCP_KEEP_IDLE.get(settings));
                        }
                    }
                    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings) &gt;= 0<span style="color: rgba(0, 0, 0, 1)">) {
                        </span><span style="color: rgba(0, 0, 255, 1)">final</span> SocketOption&lt;Integer&gt; keepIntervalOption =<span style="color: rgba(0, 0, 0, 1)"> NetUtils.getTcpKeepIntervalSocketOptionOrNull();
                        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (keepIntervalOption != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                            serverBootstrap.childOption(NioChannelOption.of(keepIntervalOption),
                                SETTING_HTTP_TCP_KEEP_INTERVAL.get(settings));
                        }
                    }
                    </span><span style="color: rgba(0, 0, 255, 1)">if</span> (SETTING_HTTP_TCP_KEEP_COUNT.get(settings) &gt;= 0<span style="color: rgba(0, 0, 0, 1)">) {
                        </span><span style="color: rgba(0, 0, 255, 1)">final</span> SocketOption&lt;Integer&gt; keepCountOption =<span style="color: rgba(0, 0, 0, 1)"> NetUtils.getTcpKeepCountSocketOptionOrNull();
                        </span><span style="color: rgba(0, 0, 255, 1)">if</span> (keepCountOption != <span style="color: rgba(0, 0, 255, 1)">null</span><span style="color: rgba(0, 0, 0, 1)">) {
                            serverBootstrap.childOption(NioChannelOption.of(keepCountOption), SETTING_HTTP_TCP_KEEP_COUNT.get(settings));
                        }
                    }
                }
            }

            </span><span style="color: rgba(0, 0, 255, 1)">final</span> ByteSizeValue tcpSendBufferSize =<span style="color: rgba(0, 0, 0, 1)"> SETTING_HTTP_TCP_SEND_BUFFER_SIZE.get(settings);
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (tcpSendBufferSize.getBytes() &gt; 0<span style="color: rgba(0, 0, 0, 1)">) {
                serverBootstrap.childOption(ChannelOption.SO_SNDBUF, Math.toIntExact(tcpSendBufferSize.getBytes()));
            }

            </span><span style="color: rgba(0, 0, 255, 1)">final</span> ByteSizeValue tcpReceiveBufferSize =<span style="color: rgba(0, 0, 0, 1)"> SETTING_HTTP_TCP_RECEIVE_BUFFER_SIZE.get(settings);
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (tcpReceiveBufferSize.getBytes() &gt; 0<span style="color: rgba(0, 0, 0, 1)">) {
                serverBootstrap.childOption(ChannelOption.SO_RCVBUF, Math.toIntExact(tcpReceiveBufferSize.getBytes()));
            }

            serverBootstrap.option(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);
            serverBootstrap.childOption(ChannelOption.RCVBUF_ALLOCATOR, recvByteBufAllocator);

            </span><span style="color: rgba(0, 0, 255, 1)">final</span> <span style="color: rgba(0, 0, 255, 1)">boolean</span> reuseAddress =<span style="color: rgba(0, 0, 0, 1)"> SETTING_HTTP_TCP_REUSE_ADDRESS.get(settings);
            serverBootstrap.option(ChannelOption.SO_REUSEADDR, reuseAddress);
            serverBootstrap.childOption(ChannelOption.SO_REUSEADDR, reuseAddress);

            bindServer();
            success </span>= <span style="color: rgba(0, 0, 255, 1)">true</span><span style="color: rgba(0, 0, 0, 1)">;
        } </span><span style="color: rgba(0, 0, 255, 1)">finally</span><span style="color: rgba(0, 0, 0, 1)"> {
            </span><span style="color: rgba(0, 0, 255, 1)">if</span> (success == <span style="color: rgba(0, 0, 255, 1)">false</span><span style="color: rgba(0, 0, 0, 1)">) {
                doStop(); </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> otherwise we leak threads since we never moved to started</span>
<span style="color: rgba(0, 0, 0, 1)">            }
        }
    }
    </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.xpack.security.transport.netty4.SecurityNetty4HttpServerTransport#configureServerChannelHandler</span>
<span style="color: rgba(0, 0, 0, 1)">    @Override
    </span><span style="color: rgba(0, 0, 255, 1)">public</span><span style="color: rgba(0, 0, 0, 1)"> ChannelHandler configureServerChannelHandler() {
        </span><span style="color: rgba(0, 0, 255, 1)">return</span> <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpSslChannelHandler();
    }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.xpack.security.transport.netty4.SecurityNetty4HttpServerTransport.HttpSslChannelHandler#HttpSslChannelHandler</span>
<span style="color: rgba(0, 0, 0, 1)">        HttpSslChannelHandler() {
            </span><span style="color: rgba(0, 0, 255, 1)">super</span>(SecurityNetty4HttpServerTransport.<span style="color: rgba(0, 0, 255, 1)">this</span><span style="color: rgba(0, 0, 0, 1)">, handlingSettings);
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.http.netty4.Netty4HttpServerTransport.HttpChannelHandler#HttpChannelHandler</span>
        <span style="color: rgba(0, 0, 255, 1)">protected</span> HttpChannelHandler(<span style="color: rgba(0, 0, 255, 1)">final</span> Netty4HttpServerTransport transport, <span style="color: rgba(0, 0, 255, 1)">final</span><span style="color: rgba(0, 0, 0, 1)"> HttpHandlingSettings handlingSettings) {
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.transport =<span style="color: rgba(0, 0, 0, 1)"> transport;
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.handlingSettings =<span style="color: rgba(0, 0, 0, 1)"> handlingSettings;
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.byteBufSizer =  <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> NettyByteBufSizer();
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.requestCreator =  <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Netty4HttpRequestCreator();
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.requestHandler = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Netty4HttpRequestHandler(transport);
            </span><span style="color: rgba(0, 0, 255, 1)">this</span>.responseCreator = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Netty4HttpResponseCreator();
        }
        </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> org.elasticsearch.http.netty4.Netty4HttpServerTransport.HttpChannelHandler#initChannel</span>
<span style="color: rgba(0, 0, 0, 1)">        @Override
        </span><span style="color: rgba(0, 0, 255, 1)">protected</span> <span style="color: rgba(0, 0, 255, 1)">void</span> initChannel(Channel ch) <span style="color: rgba(0, 0, 255, 1)">throws</span><span style="color: rgba(0, 0, 0, 1)"> Exception {
            Netty4HttpChannel nettyHttpChannel </span>= <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Netty4HttpChannel(ch);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 此处 handler 配置的相当多, 自然是因其功能复杂的原因</span>
<span style="color: rgba(0, 0, 0, 1)">            ch.attr(HTTP_CHANNEL_KEY).set(nettyHttpChannel);
            ch.pipeline().addLast(</span>"byte_buf_sizer"<span style="color: rgba(0, 0, 0, 1)">, byteBufSizer);
            ch.pipeline().addLast(</span>"read_timeout", <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> ReadTimeoutHandler(transport.readTimeoutMillis, TimeUnit.MILLISECONDS));
            </span><span style="color: rgba(0, 0, 255, 1)">final</span> HttpRequestDecoder decoder = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpRequestDecoder(
                handlingSettings.getMaxInitialLineLength(),
                handlingSettings.getMaxHeaderSize(),
                handlingSettings.getMaxChunkSize());
            decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);
            ch.pipeline().addLast(</span>"decoder"<span style="color: rgba(0, 0, 0, 1)">, decoder);
            ch.pipeline().addLast(</span>"decoder_compress", <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpContentDecompressor());
            ch.pipeline().addLast(</span>"encoder", <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpResponseEncoder());
            </span><span style="color: rgba(0, 0, 255, 1)">final</span> HttpObjectAggregator aggregator = <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpObjectAggregator(handlingSettings.getMaxContentLength());
            aggregator.setMaxCumulationBufferComponents(transport.maxCompositeBufferComponents);
            ch.pipeline().addLast(</span>"aggregator"<span style="color: rgba(0, 0, 0, 1)">, aggregator);
            </span><span style="color: rgba(0, 0, 255, 1)">if</span><span style="color: rgba(0, 0, 0, 1)"> (handlingSettings.isCompression()) {
                ch.pipeline().addLast(</span>"encoder_compress", <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> HttpContentCompressor(handlingSettings.getCompressionLevel()));
            }
            ch.pipeline().addLast(</span>"request_creator"<span style="color: rgba(0, 0, 0, 1)">, requestCreator);
            ch.pipeline().addLast(</span>"response_creator"<span style="color: rgba(0, 0, 0, 1)">, responseCreator);
            </span><span style="color: rgba(0, 128, 0, 1)">//</span><span style="color: rgba(0, 128, 0, 1)"> 最后两个处理器， pipelineing, handler, 则处理真正的业务</span>
            ch.pipeline().addLast("pipelining", <span style="color: rgba(0, 0, 255, 1)">new</span><span style="color: rgba(0, 0, 0, 1)"> Netty4HttpPipeliningHandler(logger, transport.pipeliningMaxEvents));
            ch.pipeline().addLast(</span>"handler"<span style="color: rgba(0, 0, 0, 1)">, requestHandler);
            transport.serverAcceptedChannel(nettyHttpChannel);
        }</span></pre>
</div>
<p>　　整体流程就是这样，核心就是 netty 的编程范式。最关键的就是引入最后几个处理器，这也是netty框架使用者的关注点所在。</p>
<p>　　其中，本节所讲的http server, 对应的服务端口默认是9200, 而上一节所讲对应的默认端口则是9300. 其实差别主要在于应用场景不同或者说使用的协议不同，一个是基于http协议的，一个是基于tcp协议的。http属于高层协议，其应用相对容易些，而tcp则使用起来有一些门槛，但其性能更好，用于集群间的通信则再好不过。</p>
<p>　　以上差异，并不影响我们理解 transportService 的整体逻辑。</p>
<p>&nbsp;</p>
<p>　　至于ES如何接收到网络请求后，如何处理的业务，其框架如何，其又有何具体能力？且听下回分解。</p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2021-05-02 16:09</span>&nbsp;
<a href="https://www.cnblogs.com/yougewe/">等你归去来</a>&nbsp;
阅读(<span id="post_view_count">0</span>)&nbsp;
评论(<span id="post_comment_count">0</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=14725872" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(14725872);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/10.3.1/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 251865, cb_blogApp = 'yougewe', cb_blogUserGuid = '85007e7e-9780-e511-9fc1-ac853d9f53cc';
    var cb_entryId = 14725872, cb_entryCreatedDate = '2021-05-02 16:09', cb_postType = 1;
    updatePostStats(
        [cb_entryId],
        function(id, count) { $("#post_view_count").text(count) },
        function(id, count) { $("#post_comment_count").text(count) })
    zoomManager.apply("#cnblogs_post_body img:not(.code_img_closed):not(.code_img_opened)");
</script>
<a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <div id="cnblogs_c1" class="under-post-card">
        <div id='div-gpt-ad-1592365906576-0' style='width: 300px; height: 250px;'></div>
    </div>
    <div id="under_post_card1"></div>
    <div id="cnblogs_c2" class="under-post-card">
        <div id='div-gpt-ad-1592366332455-0' style='width: 468px; height: 60px;'></div>
    </div>
    <div id="under_post_card2"></div>
    <div id="HistoryToday" class="under-post-card"></div>
    <script type="text/javascript">
       var commentManager = new blogCommentManager();
       commentManager.renderComments(0);
       fixPostBody();
       deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);       deliverT2();
       deliverC1C2();
       loadNewsAndKb();
       loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);       LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
       GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
       loadOptUnderPost();
       GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>

	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->
	<div id="sideBar">
		<div id="sideBarMain">
			<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>
<div id="sidebar_c3"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2021 等你归去来
<br /><span id="poweredby">Powered by .NET 5.0 on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <script language="javascript" type="text/javascript">
// 生成目录索引列表
// ref: http://www.cnblogs.com/wangqiguo/p/4355032.html
// modified by: zzq
function GenerateContentList()
{
    var mainContent = $('#cnblogs_post_body');
	var h2_ele = 'h3';
	var h3_ele = 'h4';
    var h2_list = $('#cnblogs_post_body ' + h2_ele);//如果你的章节标题不是h2,只需要将这里的h2换掉即可
 
    if(mainContent.length < 1)
        return;
  
    if(h2_list.length>0)
    {
        var content = '<a name="_labelTop"></a>';
        content += '<div id="navCategory" style="color:#152e97;">';
        content += '<p style="font-size:18px;"><b>目录</b></p>';
        content += '<ul>';
        for(var i=0; i<h2_list.length; i++)
        {
            var go_to_top = '<div style="text-align: right;"><a href="#_labelTop" style="color:#f68a33">返回顶部</a><a name="_label' + i + '"></a></div>';
            $(h2_list[i]).before(go_to_top);
             
            var h3_list = $(h2_list[i]).nextAll(h3_ele);
            var li3_content = '';
            for(var j=0; j<h3_list.length; j++)
            {
                var tmp = $(h3_list[j]).prevAll(h2_ele).first();
                if(!tmp.is(h2_list[i]))
                    break;
                var li3_anchor = '<a name="_label' + i + '_' + j + '"></a>';
                $(h3_list[j]).before(li3_anchor);
                li3_content += '<li><a href="#_label' + i + '_' + j + '">' + $(h3_list[j]).text() + '</a></li>';
            }
             
            var li2_content = '';
            if(li3_content.length > 0)
                li2_content = '<li><a href="#_label' + i + '">' + $(h2_list[i]).text() + '</a><ul>' + li3_content + '</ul></li>';
            else
                li2_content = '<li><a href="#_label' + i + '">' + $(h2_list[i]).text() + '</a></li>';
            content += li2_content;
        }
        content += '</ul>';
        content += '</div><p> </p>';
        content += '<hr style="height:1px;border:none;border-top:1px dashed #0066CC;"/>';
        if($('#cnblogs_post_body').length != 0 )
        {
            $($('#cnblogs_post_body')[0]).prepend(content);
        }
    }  
}
 
GenerateContentList();
</script>
    </div>

    <input type="hidden" id="antiforgery_token" value="CfDJ8L-rpLgFVEJMgssCVvNUAjs3KG2TVj19g-IcD98grVQubLtJwgaVYOKvLfcfQ_nzUVQlgtHmQNZ_ktSC84fDLX4QjX9TaED49C9KaQg9ca_QdoeRtqplzQYDlkZESnUdg3iCiAQJEmEoteK9aQUs_nQ" />
</body>
</html>
